"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/student/profile/page",{

/***/ "(app-pages-browser)/./src/lib/face-recognition.ts":
/*!*************************************!*\
  !*** ./src/lib/face-recognition.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToDescriptor: function() { return /* binding */ base64ToDescriptor; },\n/* harmony export */   checkBrowserSupport: function() { return /* binding */ checkBrowserSupport; },\n/* harmony export */   descriptorToBase64: function() { return /* binding */ descriptorToBase64; },\n/* harmony export */   detectFace: function() { return /* binding */ detectFace; },\n/* harmony export */   enrollFace: function() { return /* binding */ enrollFace; },\n/* harmony export */   loadFaceModels: function() { return /* binding */ loadFaceModels; },\n/* harmony export */   verifyFace: function() { return /* binding */ verifyFace; }\n/* harmony export */ });\n/**\r\n * Face Recognition Utilities\r\n * Uses face-api.js for face detection and recognition\r\n * \r\n * Installation: npm install face-api.js\r\n */ // Type definitions for face-api.js\n// Face recognition configuration\n// Models should be in public/models/ directory\n// Download from: https://github.com/justadudewhohacks/face-api.js-models\nconst MODEL_URL = \"/models\"; // Path to face-api.js models (relative to public folder)\nconst FACE_DETECTION_OPTIONS = {\n    minConfidence: 0.5,\n    maxResults: 1\n};\n// Initialize face-api models\nlet modelsLoaded = false;\nlet faceapiModule = null;\nasync function loadFaceModels() {\n    if (modelsLoaded) return true;\n    try {\n        // Dynamic import to avoid SSR issues\n        faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        const faceapi = faceapiModule.default || faceapiModule;\n        console.log(\"Loading face recognition models from:\", MODEL_URL);\n        await Promise.all([\n            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),\n            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),\n            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)\n        ]);\n        modelsLoaded = true;\n        console.log(\"✓ Face recognition models loaded successfully\");\n        return true;\n    } catch (error) {\n        var _error_message, _error_message1;\n        console.error(\"Failed to load face recognition models:\", error);\n        console.error(\"Error details:\", {\n            message: error === null || error === void 0 ? void 0 : error.message,\n            stack: error === null || error === void 0 ? void 0 : error.stack\n        });\n        // Provide helpful error message\n        if ((error === null || error === void 0 ? void 0 : (_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"404\")) || (error === null || error === void 0 ? void 0 : (_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Failed to fetch\"))) {\n            console.error(\"\\n        ⚠️  Models not found! Please download the face-api.js models:\\n        \\n        1. Run the download script:\\n           PowerShell: .download-face-models.ps1\\n           Or manually download from: https://github.com/justadudewhohacks/face-api.js-models\\n        \\n        2. Place the models in: public/models/\\n        \\n        Required files:\\n        - tiny_face_detector_model-weights_manifest.json\\n        - tiny_face_detector_model-shard1\\n        - face_landmark_68_model-weights_manifest.json\\n        - face_landmark_68_model-shard1\\n        - face_recognition_model-weights_manifest.json\\n        - face_recognition_model-shard1\\n      \");\n        }\n        return false;\n    }\n}\n/**\r\n * Detect face in image/video\r\n */ async function detectFace(input) {\n    try {\n        if (!faceapiModule) {\n            faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        }\n        const faceapi = faceapiModule.default || faceapiModule;\n        if (!modelsLoaded) {\n            await loadFaceModels();\n        }\n        const detection = await faceapi.detectSingleFace(input, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();\n        return detection;\n    } catch (error) {\n        console.error(\"Face detection error:\", error);\n        return null;\n    }\n}\n/**\r\n * Enroll user face - capture and store face descriptor\r\n */ async function enrollFace(videoElement) {\n    try {\n        const detection = await detectFace(videoElement);\n        if (!detection) {\n            throw new Error(\"No face detected. Please ensure your face is clearly visible.\");\n        }\n        // Check if face is too far or too close (basic liveness check)\n        const box = detection.detection.box;\n        const area = box.width * box.height;\n        const minArea = 10000; // Minimum face area\n        const maxArea = 200000; // Maximum face area\n        if (area < minArea) {\n            throw new Error(\"Please move closer to the camera.\");\n        }\n        if (area > maxArea) {\n            throw new Error(\"Please move further from the camera.\");\n        }\n        return detection.descriptor;\n    } catch (error) {\n        console.error(\"Face enrollment error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Verify face - compare with stored descriptor\r\n */ async function verifyFace(videoElement, storedDescriptor) {\n    try {\n        const detection = await detectFace(videoElement);\n        if (!detection) {\n            return {\n                match: false,\n                distance: Infinity\n            };\n        }\n        if (!faceapiModule) {\n            faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        }\n        const faceapi = faceapiModule.default || faceapiModule;\n        const distance = faceapi.euclideanDistance(detection.descriptor, storedDescriptor);\n        // Threshold for face match (lower = stricter)\n        // Typical values: 0.4-0.6\n        const threshold = 0.5;\n        const match = distance < threshold;\n        return {\n            match,\n            distance\n        };\n    } catch (error) {\n        console.error(\"Face verification error:\", error);\n        return {\n            match: false,\n            distance: Infinity\n        };\n    }\n}\n/**\r\n * Convert Float32Array to base64 for storage\r\n */ function descriptorToBase64(descriptor) {\n    const bytes = new Uint8Array(descriptor.buffer);\n    const binary = String.fromCharCode(...bytes);\n    return btoa(binary);\n}\n/**\r\n * Convert base64 back to Float32Array\r\n */ function base64ToDescriptor(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return new Float32Array(bytes.buffer);\n}\n/**\r\n * Check if browser supports required APIs\r\n */ function checkBrowserSupport() {\n    const errors = [];\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        errors.push(\"Camera access not supported\");\n    }\n    if (typeof WebAssembly === \"undefined\") {\n        errors.push(\"WebAssembly not supported (required for face-api.js)\");\n    }\n    return {\n        supported: errors.length === 0,\n        errors\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmFjZS1yZWNvZ25pdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxtQ0FBbUM7QUFNbkMsaUNBQWlDO0FBQ2pDLCtDQUErQztBQUMvQyx5RUFBeUU7QUFDekUsTUFBTUEsWUFBWSxXQUFXLHlEQUF5RDtBQUN0RixNQUFNQyx5QkFBeUI7SUFDN0JDLGVBQWU7SUFDZkMsWUFBWTtBQUNkO0FBRUEsNkJBQTZCO0FBQzdCLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsZ0JBQXFCO0FBRWxCLGVBQWVDO0lBQ3BCLElBQUlGLGNBQWMsT0FBTztJQUV6QixJQUFJO1FBQ0YscUNBQXFDO1FBQ3JDQyxnQkFBZ0IsTUFBTSxtUEFBTztRQUM3QixNQUFNRSxVQUFVRixjQUFjRyxPQUFPLElBQUlIO1FBRXpDSSxRQUFRQyxHQUFHLENBQUMseUNBQXlDVjtRQUVyRCxNQUFNVyxRQUFRQyxHQUFHLENBQUM7WUFDaEJMLFFBQVFNLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNDLFdBQVcsQ0FBQ2Y7WUFDMUNPLFFBQVFNLElBQUksQ0FBQ0csaUJBQWlCLENBQUNELFdBQVcsQ0FBQ2Y7WUFDM0NPLFFBQVFNLElBQUksQ0FBQ0ksa0JBQWtCLENBQUNGLFdBQVcsQ0FBQ2Y7U0FDN0M7UUFFREksZUFBZTtRQUNmSyxRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPO0lBQ1QsRUFBRSxPQUFPUSxPQUFZO1lBUWZBLGdCQUFtQ0E7UUFQdkNULFFBQVFTLEtBQUssQ0FBQywyQ0FBMkNBO1FBQ3pEVCxRQUFRUyxLQUFLLENBQUMsa0JBQWtCO1lBQzlCQyxPQUFPLEVBQUVELGtCQUFBQSw0QkFBQUEsTUFBT0MsT0FBTztZQUN2QkMsS0FBSyxFQUFFRixrQkFBQUEsNEJBQUFBLE1BQU9FLEtBQUs7UUFDckI7UUFFQSxnQ0FBZ0M7UUFDaEMsSUFBSUYsQ0FBQUEsa0JBQUFBLDZCQUFBQSxpQkFBQUEsTUFBT0MsT0FB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LEVBQUUsR0FBR1IsT0FBT1MsVUFBVSxDQUFDRDtJQUMvQjtJQUNBLE9BQU8sSUFBSUUsYUFBYWIsTUFBTUUsTUFBTTtBQUN0QztBQUVBOztDQUVDLEdBQ00sU0FBU1k7SUFJZCxNQUFNQyxTQUFtQixFQUFFO0lBRTNCLElBQUksQ0FBQ0MsVUFBVUMsWUFBWSxJQUFJLENBQUNELFVBQVVDLFlBQVksQ0FBQ0MsWUFBWSxFQUFFO1FBQ25FSCxPQUFPSSxJQUFJLENBQUM7SUFDZDtJQUVBLElBQUksT0FBT0MsZ0JBQWdCLGFBQWE7UUFDdENMLE9BQU9JLElBQUksQ0FBQztJQUNkO0lBRUEsT0FBTztRQUNMRSxXQUFXTixPQUFPTCxNQUFNLEtBQUs7UUFDN0JLO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2ZhY2UtcmVjb2duaXRpb24udHM/ZmUyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRmFjZSBSZWNvZ25pdGlvbiBVdGlsaXRpZXNcclxuICogVXNlcyBmYWNlLWFwaS5qcyBmb3IgZmFjZSBkZXRlY3Rpb24gYW5kIHJlY29nbml0aW9uXHJcbiAqIFxyXG4gKiBJbnN0YWxsYXRpb246IG5wbSBpbnN0YWxsIGZhY2UtYXBpLmpzXHJcbiAqL1xyXG5cclxuLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgZmFjZS1hcGkuanNcclxudHlwZSBGYWNlRGV0ZWN0aW9uID0gYW55O1xyXG50eXBlIEZhY2VMYW5kbWFya3MgPSBhbnk7XHJcbnR5cGUgV2l0aEZhY2VEZXNjcmlwdG9yPFQ+ID0gVCAmIHsgZGVzY3JpcHRvcjogRmxvYXQzMkFycmF5IH07XHJcbnR5cGUgV2l0aEZhY2VMYW5kbWFya3M8VD4gPSBUICYgeyBsYW5kbWFya3M6IEZhY2VMYW5kbWFya3MgfTtcclxuXHJcbi8vIEZhY2UgcmVjb2duaXRpb24gY29uZmlndXJhdGlvblxyXG4vLyBNb2RlbHMgc2hvdWxkIGJlIGluIHB1YmxpYy9tb2RlbHMvIGRpcmVjdG9yeVxyXG4vLyBEb3dubG9hZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vanVzdGFkdWRld2hvaGFja3MvZmFjZS1hcGkuanMtbW9kZWxzXHJcbmNvbnN0IE1PREVMX1VSTCA9ICcvbW9kZWxzJzsgLy8gUGF0aCB0byBmYWNlLWFwaS5qcyBtb2RlbHMgKHJlbGF0aXZlIHRvIHB1YmxpYyBmb2xkZXIpXHJcbmNvbnN0IEZBQ0VfREVURUNUSU9OX09QVElPTlMgPSB7XHJcbiAgbWluQ29uZmlkZW5jZTogMC41LFxyXG4gIG1heFJlc3VsdHM6IDEsXHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIGZhY2UtYXBpIG1vZGVsc1xyXG5sZXQgbW9kZWxzTG9hZGVkID0gZmFsc2U7XHJcbmxldCBmYWNlYXBpTW9kdWxlOiBhbnkgPSBudWxsO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRGYWNlTW9kZWxzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGlmIChtb2RlbHNMb2FkZWQpIHJldHVybiB0cnVlO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRHluYW1pYyBpbXBvcnQgdG8gYXZvaWQgU1NSIGlzc3Vlc1xyXG4gICAgZmFjZWFwaU1vZHVsZSA9IGF3YWl0IGltcG9ydCgnZmFjZS1hcGkuanMnKTtcclxuICAgIGNvbnN0IGZhY2VhcGkgPSBmYWNlYXBpTW9kdWxlLmRlZmF1bHQgfHwgZmFjZWFwaU1vZHVsZTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0xvYWRpbmcgZmFjZSByZWNvZ25pdGlvbiBtb2RlbHMgZnJvbTonLCBNT0RFTF9VUkwpO1xyXG4gICAgXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIGZhY2VhcGkubmV0cy50aW55RmFjZURldGVjdG9yLmxvYWRGcm9tVXJpKE1PREVMX1VSTCksXHJcbiAgICAgIGZhY2VhcGkubmV0cy5mYWNlTGFuZG1hcms2OE5ldC5sb2FkRnJvbVVyaShNT0RFTF9VUkwpLFxyXG4gICAgICBmYWNlYXBpLm5ldHMuZmFjZVJlY29nbml0aW9uTmV0LmxvYWRGcm9tVXJpKE1PREVMX1VSTCksXHJcbiAgICBdKTtcclxuXHJcbiAgICBtb2RlbHNMb2FkZWQgPSB0cnVlO1xyXG4gICAgY29uc29sZS5sb2coJ+KckyBGYWNlIHJlY29nbml0aW9uIG1vZGVscyBsb2FkZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBmYWNlIHJlY29nbml0aW9uIG1vZGVsczonLCBlcnJvcik7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIHtcclxuICAgICAgbWVzc2FnZTogZXJyb3I/Lm1lc3NhZ2UsXHJcbiAgICAgIHN0YWNrOiBlcnJvcj8uc3RhY2ssXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gUHJvdmlkZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VcclxuICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJzQwNCcpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgXHJcbiAgICAgICAg4pqg77iPICBNb2RlbHMgbm90IGZvdW5kISBQbGVhc2UgZG93bmxvYWQgdGhlIGZhY2UtYXBpLmpzIG1vZGVsczpcclxuICAgICAgICBcclxuICAgICAgICAxLiBSdW4gdGhlIGRvd25sb2FkIHNjcmlwdDpcclxuICAgICAgICAgICBQb3dlclNoZWxsOiAuXFxkb3dubG9hZC1mYWNlLW1vZGVscy5wczFcclxuICAgICAgICAgICBPciBtYW51YWxseSBkb3dubG9hZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vanVzdGFkdWRld2hvaGFja3MvZmFjZS1hcGkuanMtbW9kZWxzXHJcbiAgICAgICAgXHJcbiAgICAgICAgMi4gUGxhY2UgdGhlIG1vZGVscyBpbjogcHVibGljL21vZGVscy9cclxuICAgICAgICBcclxuICAgICAgICBSZXF1aXJlZCBmaWxlczpcclxuICAgICAgICAtIHRpbnlfZmFjZV9kZXRlY3Rvcl9tb2RlbC13ZWlnaHRzX21hbmlmZXN0Lmpzb25cclxuICAgICAgICAtIHRpbnlfZmFjZV9kZXRlY3Rvcl9tb2RlbC1zaGFyZDFcclxuICAgICAgICAtIGZhY2VfbGFuZG1hcmtfNjhfbW9kZWwtd2VpZ2h0c19tYW5pZmVzdC5qc29uXHJcbiAgICAgICAgLSBmYWNlX2xhbmRtYXJrXzY4X21vZGVsLXNoYXJkMVxyXG4gICAgICAgIC0gZmFjZV9yZWNvZ25pdGlvbl9tb2RlbC13ZWlnaHRzX21hbmlmZXN0Lmpzb25cclxuICAgICAgICAtIGZhY2VfcmVjb2duaXRpb25fbW9kZWwtc2hhcmQxXHJcbiAgICAgIGApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IGZhY2UgaW4gaW1hZ2UvdmlkZW9cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlY3RGYWNlKFxyXG4gIGlucHV0OiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50XHJcbik6IFByb21pc2U8V2l0aEZhY2VEZXNjcmlwdG9yPFdpdGhGYWNlTGFuZG1hcmtzPHtcclxuICBkZXRlY3Rpb246IEZhY2VEZXRlY3Rpb247XHJcbn0+PiB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFmYWNlYXBpTW9kdWxlKSB7XHJcbiAgICAgIGZhY2VhcGlNb2R1bGUgPSBhd2FpdCBpbXBvcnQoJ2ZhY2UtYXBpLmpzJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmYWNlYXBpID0gZmFjZWFwaU1vZHVsZS5kZWZhdWx0IHx8IGZhY2VhcGlNb2R1bGU7XHJcbiAgICBcclxuICAgIGlmICghbW9kZWxzTG9hZGVkKSB7XHJcbiAgICAgIGF3YWl0IGxvYWRGYWNlTW9kZWxzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGV0ZWN0aW9uID0gYXdhaXQgZmFjZWFwaVxyXG4gICAgICAuZGV0ZWN0U2luZ2xlRmFjZShpbnB1dCwgbmV3IGZhY2VhcGkuVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMoKSlcclxuICAgICAgLndpdGhGYWNlTGFuZG1hcmtzKClcclxuICAgICAgLndpdGhGYWNlRGVzY3JpcHRvcigpO1xyXG5cclxuICAgIHJldHVybiBkZXRlY3Rpb247XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhY2UgZGV0ZWN0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVucm9sbCB1c2VyIGZhY2UgLSBjYXB0dXJlIGFuZCBzdG9yZSBmYWNlIGRlc2NyaXB0b3JcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnJvbGxGYWNlKFxyXG4gIHZpZGVvRWxlbWVudDogSFRNTFZpZGVvRWxlbWVudFxyXG4pOiBQcm9taXNlPEZsb2F0MzJBcnJheSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGV0ZWN0aW9uID0gYXdhaXQgZGV0ZWN0RmFjZSh2aWRlb0VsZW1lbnQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWRldGVjdGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZhY2UgZGV0ZWN0ZWQuIFBsZWFzZSBlbnN1cmUgeW91ciBmYWNlIGlzIGNsZWFybHkgdmlzaWJsZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBmYWNlIGlzIHRvbyBmYXIgb3IgdG9vIGNsb3NlIChiYXNpYyBsaXZlbmVzcyBjaGVjaylcclxuICAgIGNvbnN0IGJveCA9IGRldGVjdGlvbi5kZXRlY3Rpb24uYm94O1xyXG4gICAgY29uc3QgYXJlYSA9IGJveC53aWR0aCAqIGJveC5oZWlnaHQ7XHJcbiAgICBjb25zdCBtaW5BcmVhID0gMTAwMDA7IC8vIE1pbmltdW0gZmFjZSBhcmVhXHJcbiAgICBjb25zdCBtYXhBcmVhID0gMjAwMDAwOyAvLyBNYXhpbXVtIGZhY2UgYXJlYVxyXG5cclxuICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBtb3ZlIGNsb3NlciB0byB0aGUgY2FtZXJhLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIG1vdmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRldGVjdGlvbi5kZXNjcmlwdG9yO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWNlIGVucm9sbG1lbnQgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVmVyaWZ5IGZhY2UgLSBjb21wYXJlIHdpdGggc3RvcmVkIGRlc2NyaXB0b3JcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlGYWNlKFxyXG4gIHZpZGVvRWxlbWVudDogSFRNTFZpZGVvRWxlbWVudCxcclxuICBzdG9yZWREZXNjcmlwdG9yOiBGbG9hdDMyQXJyYXlcclxuKTogUHJvbWlzZTx7IG1hdGNoOiBib29sZWFuOyBkaXN0YW5jZTogbnVtYmVyIH0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGV0ZWN0aW9uID0gYXdhaXQgZGV0ZWN0RmFjZSh2aWRlb0VsZW1lbnQpO1xyXG4gICAgXHJcbiAgICBpZiAoIWRldGVjdGlvbikge1xyXG4gICAgICByZXR1cm4geyBtYXRjaDogZmFsc2UsIGRpc3RhbmNlOiBJbmZpbml0eSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZmFjZWFwaU1vZHVsZSkge1xyXG4gICAgICBmYWNlYXBpTW9kdWxlID0gYXdhaXQgaW1wb3J0KCdmYWNlLWFwaS5qcycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmFjZWFwaSA9IGZhY2VhcGlNb2R1bGUuZGVmYXVsdCB8fCBmYWNlYXBpTW9kdWxlO1xyXG4gICAgXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IGZhY2VhcGkuZXVjbGlkZWFuRGlzdGFuY2UoXHJcbiAgICAgIGRldGVjdGlvbi5kZXNjcmlwdG9yLFxyXG4gICAgICBzdG9yZWREZXNjcmlwdG9yXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRocmVzaG9sZCBmb3IgZmFjZSBtYXRjaCAobG93ZXIgPSBzdHJpY3RlcilcclxuICAgIC8vIFR5cGljYWwgdmFsdWVzOiAwLjQtMC42XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjU7XHJcbiAgICBjb25zdCBtYXRjaCA9IGRpc3RhbmNlIDwgdGhyZXNob2xkO1xyXG5cclxuICAgIHJldHVybiB7IG1hdGNoLCBkaXN0YW5jZSB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWNlIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4geyBtYXRjaDogZmFsc2UsIGRpc3RhbmNlOiBJbmZpbml0eSB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgRmxvYXQzMkFycmF5IHRvIGJhc2U2NCBmb3Igc3RvcmFnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaXB0b3JUb0Jhc2U2NChkZXNjcmlwdG9yOiBGbG9hdDMyQXJyYXkpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGVzY3JpcHRvci5idWZmZXIpO1xyXG4gIGNvbnN0IGJpbmFyeSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMpO1xyXG4gIHJldHVybiBidG9hKGJpbmFyeSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGJhc2U2NCBiYWNrIHRvIEZsb2F0MzJBcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvRGVzY3JpcHRvcihiYXNlNjQ6IHN0cmluZyk6IEZsb2F0MzJBcnJheSB7XHJcbiAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xyXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBicm93c2VyIHN1cHBvcnRzIHJlcXVpcmVkIEFQSXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0Jyb3dzZXJTdXBwb3J0KCk6IHtcclxuICBzdXBwb3J0ZWQ6IGJvb2xlYW47XHJcbiAgZXJyb3JzOiBzdHJpbmdbXTtcclxufSB7XHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMgfHwgIW5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnQ2FtZXJhIGFjY2VzcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgZXJyb3JzLnB1c2goJ1dlYkFzc2VtYmx5IG5vdCBzdXBwb3J0ZWQgKHJlcXVpcmVkIGZvciBmYWNlLWFwaS5qcyknKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdXBwb3J0ZWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXHJcbiAgICBlcnJvcnMsXHJcbiAgfTtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIk1PREVMX1VSTCIsIkZBQ0VfREVURUNUSU9OX09QVElPTlMiLCJtaW5Db25maWRlbmNlIiwibWF4UmVzdWx0cyIsIm1vZGVsc0xvYWRlZCIsImZhY2VhcGlNb2R1bGUiLCJsb2FkRmFjZU1vZGVscyIsImZhY2VhcGkiLCJkZWZhdWx0IiwiY29uc29sZSIsImxvZyIsIlByb21pc2UiLCJhbGwiLCJuZXRzIiwidGlueUZhY2VEZXRlY3RvciIsImxvYWRGcm9tVXJpIiwiZmFjZUxhbmRtYXJrNjhOZXQiLCJmYWNlUmVjb2duaXRpb25OZXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsImluY2x1ZGVzIiwiZGV0ZWN0RmFjZSIsImlucHV0IiwiZGV0ZWN0aW9uIiwiZGV0ZWN0U2luZ2xlRmFjZSIsIlRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zIiwid2l0aEZhY2VMYW5kbWFya3MiLCJ3aXRoRmFjZURlc2NyaXB0b3IiLCJlbnJvbGxGYWNlIiwidmlkZW9FbGVtZW50IiwiRXJyb3IiLCJib3giLCJhcmVhIiwid2lkdGgiLCJoZWlnaHQiLCJtaW5BcmVhIiwibWF4QXJlYSIsImRlc2NyaXB0b3IiLCJ2ZXJpZnlGYWNlIiwic3RvcmVkRGVzY3JpcHRvciIsIm1hdGNoIiwiZGlzdGFuY2UiLCJJbmZpbml0eSIsImV1Y2xpZGVhbkRpc3RhbmNlIiwidGhyZXNob2xkIiwiZGVzY3JpcHRvclRvQmFzZTY0IiwiYnl0ZXMiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYmluYXJ5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYnRvYSIsImJhc2U2NFRvRGVzY3JpcHRvciIsImJhc2U2NCIsImF0b2IiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsIkZsb2F0MzJBcnJheSIsImNoZWNrQnJvd3NlclN1cHBvcnQiLCJlcnJvcnMiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJwdXNoIiwiV2ViQXNzZW1ibHkiLCJzdXBwb3J0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/face-recognition.ts\n"));

/***/ })

});