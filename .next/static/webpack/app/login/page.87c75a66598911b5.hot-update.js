"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/lib/face-recognition.ts":
/*!*************************************!*\
  !*** ./src/lib/face-recognition.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToDescriptor: function() { return /* binding */ base64ToDescriptor; },\n/* harmony export */   checkBrowserSupport: function() { return /* binding */ checkBrowserSupport; },\n/* harmony export */   descriptorToBase64: function() { return /* binding */ descriptorToBase64; },\n/* harmony export */   detectFace: function() { return /* binding */ detectFace; },\n/* harmony export */   enrollFace: function() { return /* binding */ enrollFace; },\n/* harmony export */   loadFaceModels: function() { return /* binding */ loadFaceModels; },\n/* harmony export */   verifyFace: function() { return /* binding */ verifyFace; }\n/* harmony export */ });\n/**\r\n * Face Recognition Utilities\r\n * Uses face-api.js for face detection and recognition\r\n * \r\n * Installation: npm install face-api.js\r\n */ // Type definitions for face-api.js\n// Face recognition configuration\nconst MODEL_URL = \"/models\"; // Path to face-api.js models\nconst FACE_DETECTION_OPTIONS = {\n    minConfidence: 0.5,\n    maxResults: 1\n};\n// Initialize face-api models\nlet modelsLoaded = false;\nlet faceapiModule = null;\nasync function loadFaceModels() {\n    if (modelsLoaded) return true;\n    try {\n        // Dynamic import to avoid SSR issues\n        faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        const faceapi = faceapiModule.default || faceapiModule;\n        console.log(\"Loading face recognition models from:\", MODEL_URL);\n        await Promise.all([\n            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),\n            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),\n            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)\n        ]);\n        modelsLoaded = true;\n        console.log(\"✓ Face recognition models loaded successfully\");\n        return true;\n    } catch (error) {\n        var _error_message, _error_message1;\n        console.error(\"Failed to load face recognition models:\", error);\n        console.error(\"Error details:\", {\n            message: error === null || error === void 0 ? void 0 : error.message,\n            stack: error === null || error === void 0 ? void 0 : error.stack\n        });\n        // Provide helpful error message\n        if ((error === null || error === void 0 ? void 0 : (_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"404\")) || (error === null || error === void 0 ? void 0 : (_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Failed to fetch\"))) {\n            console.error(\"\\n        ⚠️  Models not found! Please download the face-api.js models:\\n        \\n        1. Run the download script:\\n           PowerShell: .download-face-models.ps1\\n           Or manually download from: https://github.com/justadudewhohacks/face-api.js-models\\n        \\n        2. Place the models in: public/models/\\n        \\n        Required files:\\n        - tiny_face_detector_model-weights_manifest.json\\n        - tiny_face_detector_model-shard1\\n        - face_landmark_68_model-weights_manifest.json\\n        - face_landmark_68_model-shard1\\n        - face_recognition_model-weights_manifest.json\\n        - face_recognition_model-shard1\\n      \");\n        }\n        return false;\n    }\n}\n/**\r\n * Detect face in image/video\r\n */ async function detectFace(input) {\n    try {\n        if (!faceapiModule) {\n            faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        }\n        const faceapi = faceapiModule.default || faceapiModule;\n        if (!modelsLoaded) {\n            await loadFaceModels();\n        }\n        const detection = await faceapi.detectSingleFace(input, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();\n        return detection;\n    } catch (error) {\n        console.error(\"Face detection error:\", error);\n        return null;\n    }\n}\n/**\r\n * Enroll user face - capture and store face descriptor\r\n */ async function enrollFace(videoElement) {\n    try {\n        const detection = await detectFace(videoElement);\n        if (!detection) {\n            throw new Error(\"No face detected. Please ensure your face is clearly visible.\");\n        }\n        // Check if face is too far or too close (basic liveness check)\n        const box = detection.detection.box;\n        const area = box.width * box.height;\n        const minArea = 10000; // Minimum face area\n        const maxArea = 200000; // Maximum face area\n        if (area < minArea) {\n            throw new Error(\"Please move closer to the camera.\");\n        }\n        if (area > maxArea) {\n            throw new Error(\"Please move further from the camera.\");\n        }\n        return detection.descriptor;\n    } catch (error) {\n        console.error(\"Face enrollment error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Verify face - compare with stored descriptor\r\n */ async function verifyFace(videoElement, storedDescriptor) {\n    try {\n        const detection = await detectFace(videoElement);\n        if (!detection) {\n            return {\n                match: false,\n                distance: Infinity\n            };\n        }\n        if (!faceapiModule) {\n            faceapiModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_face-api_js_build_es6_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! face-api.js */ \"(app-pages-browser)/./node_modules/face-api.js/build/es6/index.js\"));\n        }\n        const faceapi = faceapiModule.default || faceapiModule;\n        const distance = faceapi.euclideanDistance(detection.descriptor, storedDescriptor);\n        // Threshold for face match (lower = stricter)\n        // Typical values: 0.4-0.6\n        const threshold = 0.5;\n        const match = distance < threshold;\n        return {\n            match,\n            distance\n        };\n    } catch (error) {\n        console.error(\"Face verification error:\", error);\n        return {\n            match: false,\n            distance: Infinity\n        };\n    }\n}\n/**\r\n * Convert Float32Array to base64 for storage\r\n */ function descriptorToBase64(descriptor) {\n    const bytes = new Uint8Array(descriptor.buffer);\n    const binary = String.fromCharCode(...bytes);\n    return btoa(binary);\n}\n/**\r\n * Convert base64 back to Float32Array\r\n */ function base64ToDescriptor(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return new Float32Array(bytes.buffer);\n}\n/**\r\n * Check if browser supports required APIs\r\n */ function checkBrowserSupport() {\n    const errors = [];\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        errors.push(\"Camera access not supported\");\n    }\n    if (typeof WebAssembly === \"undefined\") {\n        errors.push(\"WebAssembly not supported (required for face-api.js)\");\n    }\n    return {\n        supported: errors.length === 0,\n        errors\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmFjZS1yZWNvZ25pdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FFRCxtQ0FBbUM7QUFNbkMsaUNBQWlDO0FBQ2pDLE1BQU1BLFlBQVksV0FBVyw2QkFBNkI7QUFDMUQsTUFBTUMseUJBQXlCO0lBQzdCQyxlQUFlO0lBQ2ZDLFlBQVk7QUFDZDtBQUVBLDZCQUE2QjtBQUM3QixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLGdCQUFxQjtBQUVsQixlQUFlQztJQUNwQixJQUFJRixjQUFjLE9BQU87SUFFekIsSUFBSTtRQUNGLHFDQUFxQztRQUNyQ0MsZ0JBQWdCLE1BQU0sbVBBQU87UUFDN0IsTUFBTUUsVUFBVUYsY0FBY0csT0FBTyxJQUFJSDtRQUV6Q0ksUUFBUUMsR0FBRyxDQUFDLHlDQUF5Q1Y7UUFFckQsTUFBTVcsUUFBUUMsR0FBRyxDQUFDO1lBQ2hCTCxRQUFRTSxJQUFJLENBQUNDLGdCQUFnQixDQUFDQyxXQUFXLENBQUNmO1lBQzFDTyxRQUFRTSxJQUFJLENBQUNHLGlCQUFpQixDQUFDRCxXQUFXLENBQUNmO1lBQzNDTyxRQUFRTSxJQUFJLENBQUNJLGtCQUFrQixDQUFDRixXQUFXLENBQUNmO1NBQzdDO1FBRURJLGVBQWU7UUFDZkssUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBTztJQUNULEVBQUUsT0FBT1EsT0FBWTtZQVFmQSxnQkFBbUNBO1FBUHZDVCxRQUFRUyxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RFQsUUFBUVMsS0FBSyxDQUFDLGtCQUFrQjtZQUM5QkMsT0FBTyxFQUFFRCxrQkFBQUEsNEJBQUFBLE1BQU9DLE9BQU87WUFDdkJDLEtBQUssRUFBRUYsa0JBQUFBLDRCQUFBQSxNQUFPRSxLQUFLO1FBQ3JCO1FBRUEsZ0NBQWdDO1FBQ2hDLElBQUlGLENBQUFBLGtCQUFBQSw2QkFBQUEsaUJBQUFBLE1BQU9DLE9BQU8sY0FBZEQscUNBQUFBLGVBQWdCRyxRQUFR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Q0Q7SUFDL0I7SUFDQSxPQUFPLElBQUlFLGFBQWFiLE1BQU1FLE1BQU07QUFDdEM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNZO0lBSWQsTUFBTUMsU0FBbUIsRUFBRTtJQUUzQixJQUFJLENBQUNDLFVBQVVDLFlBQVksSUFBSSxDQUFDRCxVQUFVQyxZQUFZLENBQUNDLFlBQVksRUFBRTtRQUNuRUgsT0FBT0ksSUFBSSxDQUFDO0lBQ2Q7SUFFQSxJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1FBQ3RDTCxPQUFPSSxJQUFJLENBQUM7SUFDZDtJQUVBLE9BQU87UUFDTEUsV0FBV04sT0FBT0wsTUFBTSxLQUFLO1FBQzdCSztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9mYWNlLXJlY29nbml0aW9uLnRzP2ZlMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEZhY2UgUmVjb2duaXRpb24gVXRpbGl0aWVzXHJcbiAqIFVzZXMgZmFjZS1hcGkuanMgZm9yIGZhY2UgZGV0ZWN0aW9uIGFuZCByZWNvZ25pdGlvblxyXG4gKiBcclxuICogSW5zdGFsbGF0aW9uOiBucG0gaW5zdGFsbCBmYWNlLWFwaS5qc1xyXG4gKi9cclxuXHJcbi8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGZhY2UtYXBpLmpzXHJcbnR5cGUgRmFjZURldGVjdGlvbiA9IGFueTtcclxudHlwZSBGYWNlTGFuZG1hcmtzID0gYW55O1xyXG50eXBlIFdpdGhGYWNlRGVzY3JpcHRvcjxUPiA9IFQgJiB7IGRlc2NyaXB0b3I6IEZsb2F0MzJBcnJheSB9O1xyXG50eXBlIFdpdGhGYWNlTGFuZG1hcmtzPFQ+ID0gVCAmIHsgbGFuZG1hcmtzOiBGYWNlTGFuZG1hcmtzIH07XHJcblxyXG4vLyBGYWNlIHJlY29nbml0aW9uIGNvbmZpZ3VyYXRpb25cclxuY29uc3QgTU9ERUxfVVJMID0gJy9tb2RlbHMnOyAvLyBQYXRoIHRvIGZhY2UtYXBpLmpzIG1vZGVsc1xyXG5jb25zdCBGQUNFX0RFVEVDVElPTl9PUFRJT05TID0ge1xyXG4gIG1pbkNvbmZpZGVuY2U6IDAuNSxcclxuICBtYXhSZXN1bHRzOiAxLFxyXG59O1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBmYWNlLWFwaSBtb2RlbHNcclxubGV0IG1vZGVsc0xvYWRlZCA9IGZhbHNlO1xyXG5sZXQgZmFjZWFwaU1vZHVsZTogYW55ID0gbnVsbDtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkRmFjZU1vZGVscygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBpZiAobW9kZWxzTG9hZGVkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIER5bmFtaWMgaW1wb3J0IHRvIGF2b2lkIFNTUiBpc3N1ZXNcclxuICAgIGZhY2VhcGlNb2R1bGUgPSBhd2FpdCBpbXBvcnQoJ2ZhY2UtYXBpLmpzJyk7XHJcbiAgICBjb25zdCBmYWNlYXBpID0gZmFjZWFwaU1vZHVsZS5kZWZhdWx0IHx8IGZhY2VhcGlNb2R1bGU7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIGZhY2UgcmVjb2duaXRpb24gbW9kZWxzIGZyb206JywgTU9ERUxfVVJMKTtcclxuICAgIFxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBmYWNlYXBpLm5ldHMudGlueUZhY2VEZXRlY3Rvci5sb2FkRnJvbVVyaShNT0RFTF9VUkwpLFxyXG4gICAgICBmYWNlYXBpLm5ldHMuZmFjZUxhbmRtYXJrNjhOZXQubG9hZEZyb21VcmkoTU9ERUxfVVJMKSxcclxuICAgICAgZmFjZWFwaS5uZXRzLmZhY2VSZWNvZ25pdGlvbk5ldC5sb2FkRnJvbVVyaShNT0RFTF9VUkwpLFxyXG4gICAgXSk7XHJcblxyXG4gICAgbW9kZWxzTG9hZGVkID0gdHJ1ZTtcclxuICAgIGNvbnNvbGUubG9nKCfinJMgRmFjZSByZWNvZ25pdGlvbiBtb2RlbHMgbG9hZGVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgZmFjZSByZWNvZ25pdGlvbiBtb2RlbHM6JywgZXJyb3IpO1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yPy5tZXNzYWdlLFxyXG4gICAgICBzdGFjazogZXJyb3I/LnN0YWNrLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFByb3ZpZGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXHJcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCc0MDQnKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFxyXG4gICAgICAgIOKaoO+4jyAgTW9kZWxzIG5vdCBmb3VuZCEgUGxlYXNlIGRvd25sb2FkIHRoZSBmYWNlLWFwaS5qcyBtb2RlbHM6XHJcbiAgICAgICAgXHJcbiAgICAgICAgMS4gUnVuIHRoZSBkb3dubG9hZCBzY3JpcHQ6XHJcbiAgICAgICAgICAgUG93ZXJTaGVsbDogLlxcZG93bmxvYWQtZmFjZS1tb2RlbHMucHMxXHJcbiAgICAgICAgICAgT3IgbWFudWFsbHkgZG93bmxvYWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2p1c3RhZHVkZXdob2hhY2tzL2ZhY2UtYXBpLmpzLW1vZGVsc1xyXG4gICAgICAgIFxyXG4gICAgICAgIDIuIFBsYWNlIHRoZSBtb2RlbHMgaW46IHB1YmxpYy9tb2RlbHMvXHJcbiAgICAgICAgXHJcbiAgICAgICAgUmVxdWlyZWQgZmlsZXM6XHJcbiAgICAgICAgLSB0aW55X2ZhY2VfZGV0ZWN0b3JfbW9kZWwtd2VpZ2h0c19tYW5pZmVzdC5qc29uXHJcbiAgICAgICAgLSB0aW55X2ZhY2VfZGV0ZWN0b3JfbW9kZWwtc2hhcmQxXHJcbiAgICAgICAgLSBmYWNlX2xhbmRtYXJrXzY4X21vZGVsLXdlaWdodHNfbWFuaWZlc3QuanNvblxyXG4gICAgICAgIC0gZmFjZV9sYW5kbWFya182OF9tb2RlbC1zaGFyZDFcclxuICAgICAgICAtIGZhY2VfcmVjb2duaXRpb25fbW9kZWwtd2VpZ2h0c19tYW5pZmVzdC5qc29uXHJcbiAgICAgICAgLSBmYWNlX3JlY29nbml0aW9uX21vZGVsLXNoYXJkMVxyXG4gICAgICBgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBmYWNlIGluIGltYWdlL3ZpZGVvXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZWN0RmFjZShcclxuICBpbnB1dDogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudFxyXG4pOiBQcm9taXNlPFdpdGhGYWNlRGVzY3JpcHRvcjxXaXRoRmFjZUxhbmRtYXJrczx7XHJcbiAgZGV0ZWN0aW9uOiBGYWNlRGV0ZWN0aW9uO1xyXG59Pj4gfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghZmFjZWFwaU1vZHVsZSkge1xyXG4gICAgICBmYWNlYXBpTW9kdWxlID0gYXdhaXQgaW1wb3J0KCdmYWNlLWFwaS5qcycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmFjZWFwaSA9IGZhY2VhcGlNb2R1bGUuZGVmYXVsdCB8fCBmYWNlYXBpTW9kdWxlO1xyXG4gICAgXHJcbiAgICBpZiAoIW1vZGVsc0xvYWRlZCkge1xyXG4gICAgICBhd2FpdCBsb2FkRmFjZU1vZGVscygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRldGVjdGlvbiA9IGF3YWl0IGZhY2VhcGlcclxuICAgICAgLmRldGVjdFNpbmdsZUZhY2UoaW5wdXQsIG5ldyBmYWNlYXBpLlRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zKCkpXHJcbiAgICAgIC53aXRoRmFjZUxhbmRtYXJrcygpXHJcbiAgICAgIC53aXRoRmFjZURlc2NyaXB0b3IoKTtcclxuXHJcbiAgICByZXR1cm4gZGV0ZWN0aW9uO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWNlIGRldGVjdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnJvbGwgdXNlciBmYWNlIC0gY2FwdHVyZSBhbmQgc3RvcmUgZmFjZSBkZXNjcmlwdG9yXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5yb2xsRmFjZShcclxuICB2aWRlb0VsZW1lbnQ6IEhUTUxWaWRlb0VsZW1lbnRcclxuKTogUHJvbWlzZTxGbG9hdDMyQXJyYXkgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRldGVjdGlvbiA9IGF3YWl0IGRldGVjdEZhY2UodmlkZW9FbGVtZW50KTtcclxuICAgIFxyXG4gICAgaWYgKCFkZXRlY3Rpb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmYWNlIGRldGVjdGVkLiBQbGVhc2UgZW5zdXJlIHlvdXIgZmFjZSBpcyBjbGVhcmx5IHZpc2libGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgZmFjZSBpcyB0b28gZmFyIG9yIHRvbyBjbG9zZSAoYmFzaWMgbGl2ZW5lc3MgY2hlY2spXHJcbiAgICBjb25zdCBib3ggPSBkZXRlY3Rpb24uZGV0ZWN0aW9uLmJveDtcclxuICAgIGNvbnN0IGFyZWEgPSBib3gud2lkdGggKiBib3guaGVpZ2h0O1xyXG4gICAgY29uc3QgbWluQXJlYSA9IDEwMDAwOyAvLyBNaW5pbXVtIGZhY2UgYXJlYVxyXG4gICAgY29uc3QgbWF4QXJlYSA9IDIwMDAwMDsgLy8gTWF4aW11bSBmYWNlIGFyZWFcclxuXHJcbiAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgbW92ZSBjbG9zZXIgdG8gdGhlIGNhbWVyYS4nKTtcclxuICAgIH1cclxuICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBtb3ZlIGZ1cnRoZXIgZnJvbSB0aGUgY2FtZXJhLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZXRlY3Rpb24uZGVzY3JpcHRvcjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFjZSBlbnJvbGxtZW50IGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBmYWNlIC0gY29tcGFyZSB3aXRoIHN0b3JlZCBkZXNjcmlwdG9yXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RmFjZShcclxuICB2aWRlb0VsZW1lbnQ6IEhUTUxWaWRlb0VsZW1lbnQsXHJcbiAgc3RvcmVkRGVzY3JpcHRvcjogRmxvYXQzMkFycmF5XHJcbik6IFByb21pc2U8eyBtYXRjaDogYm9vbGVhbjsgZGlzdGFuY2U6IG51bWJlciB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRldGVjdGlvbiA9IGF3YWl0IGRldGVjdEZhY2UodmlkZW9FbGVtZW50KTtcclxuICAgIFxyXG4gICAgaWYgKCFkZXRlY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHsgbWF0Y2g6IGZhbHNlLCBkaXN0YW5jZTogSW5maW5pdHkgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWZhY2VhcGlNb2R1bGUpIHtcclxuICAgICAgZmFjZWFwaU1vZHVsZSA9IGF3YWl0IGltcG9ydCgnZmFjZS1hcGkuanMnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZhY2VhcGkgPSBmYWNlYXBpTW9kdWxlLmRlZmF1bHQgfHwgZmFjZWFwaU1vZHVsZTtcclxuICAgIFxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBmYWNlYXBpLmV1Y2xpZGVhbkRpc3RhbmNlKFxyXG4gICAgICBkZXRlY3Rpb24uZGVzY3JpcHRvcixcclxuICAgICAgc3RvcmVkRGVzY3JpcHRvclxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUaHJlc2hvbGQgZm9yIGZhY2UgbWF0Y2ggKGxvd2VyID0gc3RyaWN0ZXIpXHJcbiAgICAvLyBUeXBpY2FsIHZhbHVlczogMC40LTAuNlxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gMC41O1xyXG4gICAgY29uc3QgbWF0Y2ggPSBkaXN0YW5jZSA8IHRocmVzaG9sZDtcclxuXHJcbiAgICByZXR1cm4geyBtYXRjaCwgZGlzdGFuY2UgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFjZSB2ZXJpZmljYXRpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgbWF0Y2g6IGZhbHNlLCBkaXN0YW5jZTogSW5maW5pdHkgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IEZsb2F0MzJBcnJheSB0byBiYXNlNjQgZm9yIHN0b3JhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmlwdG9yVG9CYXNlNjQoZGVzY3JpcHRvcjogRmxvYXQzMkFycmF5KTogc3RyaW5nIHtcclxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRlc2NyaXB0b3IuYnVmZmVyKTtcclxuICBjb25zdCBiaW5hcnkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ5dGVzKTtcclxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBiYXNlNjQgYmFjayB0byBGbG9hdDMyQXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0Rlc2NyaXB0b3IoYmFzZTY0OiBzdHJpbmcpOiBGbG9hdDMyQXJyYXkge1xyXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcclxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyByZXF1aXJlZCBBUElzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tCcm93c2VyU3VwcG9ydCgpOiB7XHJcbiAgc3VwcG9ydGVkOiBib29sZWFuO1xyXG4gIGVycm9yczogc3RyaW5nW107XHJcbn0ge1xyXG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIHx8ICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ0NhbWVyYSBhY2Nlc3Mgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGVycm9ycy5wdXNoKCdXZWJBc3NlbWJseSBub3Qgc3VwcG9ydGVkIChyZXF1aXJlZCBmb3IgZmFjZS1hcGkuanMpJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3VwcG9ydGVkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxyXG4gICAgZXJyb3JzLFxyXG4gIH07XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJNT0RFTF9VUkwiLCJGQUNFX0RFVEVDVElPTl9PUFRJT05TIiwibWluQ29uZmlkZW5jZSIsIm1heFJlc3VsdHMiLCJtb2RlbHNMb2FkZWQiLCJmYWNlYXBpTW9kdWxlIiwibG9hZEZhY2VNb2RlbHMiLCJmYWNlYXBpIiwiZGVmYXVsdCIsImNvbnNvbGUiLCJsb2ciLCJQcm9taXNlIiwiYWxsIiwibmV0cyIsInRpbnlGYWNlRGV0ZWN0b3IiLCJsb2FkRnJvbVVyaSIsImZhY2VMYW5kbWFyazY4TmV0IiwiZmFjZVJlY29nbml0aW9uTmV0IiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJpbmNsdWRlcyIsImRldGVjdEZhY2UiLCJpbnB1dCIsImRldGVjdGlvbiIsImRldGVjdFNpbmdsZUZhY2UiLCJUaW55RmFjZURldGVjdG9yT3B0aW9ucyIsIndpdGhGYWNlTGFuZG1hcmtzIiwid2l0aEZhY2VEZXNjcmlwdG9yIiwiZW5yb2xsRmFjZSIsInZpZGVvRWxlbWVudCIsIkVycm9yIiwiYm94IiwiYXJlYSIsIndpZHRoIiwiaGVpZ2h0IiwibWluQXJlYSIsIm1heEFyZWEiLCJkZXNjcmlwdG9yIiwidmVyaWZ5RmFjZSIsInN0b3JlZERlc2NyaXB0b3IiLCJtYXRjaCIsImRpc3RhbmNlIiwiSW5maW5pdHkiLCJldWNsaWRlYW5EaXN0YW5jZSIsInRocmVzaG9sZCIsImRlc2NyaXB0b3JUb0Jhc2U2NCIsImJ5dGVzIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImJpbmFyeSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJiYXNlNjRUb0Rlc2NyaXB0b3IiLCJiYXNlNjQiLCJhdG9iIiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJGbG9hdDMyQXJyYXkiLCJjaGVja0Jyb3dzZXJTdXBwb3J0IiwiZXJyb3JzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwicHVzaCIsIldlYkFzc2VtYmx5Iiwic3VwcG9ydGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/face-recognition.ts\n"));

/***/ })

});